#!/usr/bin/env bash

# Sorry, everyone
if (( ${BASH_VERSION%%.*} < 4 )); then
  echo "This script requires Bash >= 4. On OSX, try: brew install bash"
  exit 1
fi

# Any error is fatal.
set -e
set -o pipefail
# set -x # uncomment for debugging.
# set -u

# Known URLs, directories and versions
OPAM_URL=https://github.com/fdopen/opam-repository-mingw/releases/download/0.0.0.1/opam64.tar.xz
OPAM_VERSION=4.05.0+mingw64c
# Provide for a Python, necessary for scons
# (all other occurrences of python can use whatever python 2 is in the PATH, be it Windows or Cygwin)
# NOTE: if you change SCONS_PYTHON_MAJOR and/or SCONS_PYTHON_MINOR, then please also update scons-python-version-test.py
SCONS_PYTHON_MAJOR=3
SCONS_PYTHON_MINOR=6
SCONS_PYTHON_MAJOR_MINOR=$SCONS_PYTHON_MAJOR.$SCONS_PYTHON_MINOR
SCONS_PYTHON_REVISION=6
SCONS_PYTHON_VER=$SCONS_PYTHON_MAJOR_MINOR.$SCONS_PYTHON_REVISION
# NOTE: if you change SCONS_VER, then please also update scons-python-version-test.py
SCONS_VER=3.0.1
SCONS_INSTALL_DIR=scons-$SCONS_VER
SCONS_INSTALL_FILE=$SCONS_INSTALL_DIR.tar.gz
SCONS_INSTALL_POINT=https://downloads.sourceforge.net/project/scons/scons/$SCONS_VER/$SCONS_INSTALL_FILE
SED=$(which gsed >/dev/null 2>&1 && echo gsed || echo sed)

# OPAM_AUTO_SETUP defines the opam command-line option to
# automatically setup environment variables into
# $EVEREST_ENV_DEST_FILE . By default, it is left empty, but it is set
# to --auto-setup if everest is run with --yes, i.e. in
# non-interactive mode
OPAM_AUTO_SETUP=

# No-interaction when this script is used for CI purposes
INTERACTIVE=true
make_non_interactive () {
  INTERACTIVE=false
  export GIT_SSH_COMMAND="ssh -oBatchMode=yes"
  export GIT_TERMINAL_PROMPT=0
  export OPAMYES=1
  OPAM_AUTO_SETUP=--auto-setup
}

# The parallel option, either empty (by default), or -j n,
# as specified on the command line.
# WARNING: in the latter case, it MUST be interpreted as two words, so
# NEVER quote it as "$parallel_opt"
# Use $parallel_opt instead
unset parallel_opt

# The -k option (to instruct make to keep going upon a failure),
# disabled by default
unset keep_going_opt

# The file where to store customized environment variables
# (default is $HOME/.bash_profile)
if [[ $EVEREST_ENV_DEST_FILE == "" ]] ; then
  EVEREST_ENV_DEST_FILE="$HOME/.bash_profile"
fi

# The whole script makes the assumption that we're in the everest directory;
# this is a conservative method that ensures we switch to this directory first
# thing. Basically, this supports:
# - calling "everest" (in the PATH)
# - calling "./everest" (same directory)
# - calling "/path/to/everest"
# - calling "../path/to/everest"
# This bails for corner cases, e.g. "source everest" or "wget http://.../everest | bash"
cd_to_everest () {
  echo -n "# Switching to the everest directory"
  if [[ ${0##*/} != "everest" ]]; then
    echo -e "\nThis script must be called via ./everest"
    exit 1
  fi
  if [[ $0 != ${0#*/} ]]; then
    # Relative or absolute path (contains /)
    cd $(dirname $0)
  else
    # Called via the path
    cd $(dirname $(which $0))
  fi
  echo " ... now in $(pwd)"
  echo
}
# Save the initial working directory, to switch to when $0 pull calls
# the new version of $0
initial_pwd="$(pwd)"
cd_to_everest

# "Modularity": include other files (requires us to be in the right directory)
source lib.sh
source repositories.sh
source hashes.sh

# Windows only: Visual Studio's command line to set up environment (VS_ENV_CMD)
if is_windows ; then
  # Starting from Visual Studio 2017, version 15.2 or later,
  # we can determine the location of a VS install
  # using vswhere.exe, see:
  # https://docs.microsoft.com/en-us/visualstudio/extensibility/locating-visual-studio
  if
    VSWHERE_WINDOWS="$(cmd.exe /C 'echo %ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe' | sed 's!\r!!g')" &&
    VSWHERE=$(cygpath -u "$VSWHERE_WINDOWS") &&
    VS_HOME=$("$VSWHERE" -requires Microsoft.VisualStudio.Component.FSharp -format value -property InstallationPath | sed 's!\r!!g') &&
    [[ -n "$VS_HOME" ]]
  then
    # Visual Studio 2017 (15.2) or later
    # vcvarsall.bat has been superseded by vsdevcmd.bat, see:
    # https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/how-to-set-environment-variables-for-the-visual-studio-command-line
    VSDEVCMD_PATH=$(cygpath -u "$VS_HOME")/Common7/Tools
    VSDEVCMD=$(cygpath -w "$VSDEVCMD_PATH/VsDevCmd.bat")
    # Here we assume that BOTH the target platform
    # and the host platform are amd64.
    VS_ENV_CMD='"'"$VSDEVCMD"'" -arch=amd64 -host_arch=amd64'
  else
    # Older versions are based on vcvarsall.bat
    if [[ -v VS140COMNTOOLS ]]; then
      # Visual Studio 2015 (14.x)
      VS_TOOLS_PATH="$VS140COMNTOOLS"
    elif [[ -v VS120COMNTOOLS ]]; then
      # Visual Studio 2012 (12.x)
      VS_TOOLS_PATH="$VS120COMNTOOLS"
    elif [[ -v VS110COMNTOOLS ]]; then
      # Visual Studio 2010 (10.x)
      VS_TOOLS_PATH="$VS110COMNTOOLS"
    else
      # Not found
      echo Could not find Visual Studio
      exit 1
    fi
    VCVARSALL_PATH="$VS_TOOLS_PATH"/../../VC
    VCVARSALL=$(cygpath -d "$VCVARSALL_PATH/vcvarsall.bat")
    # Here we assume that BOTH the target platform
    # and the host platform are amd64.
    VS_ENV_CMD="$VCVARSALL amd64"
  fi
fi

# May be overridden to include a single project
ALL_PROJECTS="${!repositories[@]}"

# ------------------------------------------------------------------------------
# A series of helpers
# ------------------------------------------------------------------------------

write_to_env_dest_file () {
  str="$1"
  # NOTE: "$str" contains line breaks, since it actually contains
  # several commands, with each command on its own line.
  # These line breaks must be preserved.
  eval "$str"
  echo "$str" >> "$EVEREST_ENV_DEST_FILE"
  magenta "Remember to run source \"$EVEREST_ENV_DEST_FILE\" in your terminal afterwards!"
}

# Append $1 to the (Cygwin) path
windows_append_path () {
  path=$(cygpath -m -d "$1")
  path=$(cygpath "$path")
  str="
    # This line automatically added by $0
    export PATH=\"$path\":\$PATH"
  write_to_env_dest_file "$str"
  export PATH="$path":"$PATH"
}

# Windows requires several tools that can be installed via Visual Studio, but
# these usually aren't in the PATH. Check in the usual locations, then offer to
# customize "$EVEREST_ENV_DEST_FILE"
#   $1: name of command to check for
#   $2: candidate directory where it may reside
# NOTE: this function is also used to locate python and scons
windows_check_or_modify_env_dest_file () {
  if ! command -v $1 >/dev/null 2>&1; then
    red "ERROR: $1 not found in PATH"
    if [ -f "$2"/$1 ]; then
      magenta "$1 found in $2; add to PATH via $EVEREST_ENV_DEST_FILE ? [Yn]"
      if prompt_yes true false; then
        windows_append_path "$2"
      fi
    else
      red "$1 not found in $2, bailing"
      echo Hint: it looks like some VS2015 components are missing. We need \
        VS2015, including the C++ components. You can run the VS2015 installer \
        and choose a custom setup, to ensure you have both F# and the C++ \
        components. Download it from: \
        https://go.microsoft.com/fwlink/?LinkId=532606&clcid=0x409
      exit 1
    fi
  fi

  echo "... found $1"
}

write_z3_env_dest_file () {
  str="
    # This line automatically added by $0
    export PATH=$(pwd)/$1/bin:\$PATH"
  write_to_env_dest_file "$str"
}

write_cygwin_env_dest_file () {
  str="
    # These lines automatically added by $0
    export PATH=/usr/x86_64-w64-mingw32/sys-root/mingw/bin:\$PATH
    export CYGWIN='winsymlinks:native'"
  write_to_env_dest_file "$str"
}

write_everest_env_dest_file () {
  if is_windows; then
    str="
    # These lines automatically added by $0
    export EVEREST_SCONS_CACHE_DIR=$(cygpath -m \"$TEMP\"/everest)"
  else
    str="
    # These lines automatically added by $0
    export EVEREST_SCONS_CACHE_DIR=/tmp/everest"
  fi
  write_to_env_dest_file "$str"
}

cygsetup="setup-x86_64.exe"
cygsetup_args="--no-desktop --no-shortcuts --no-startmenu --wait --quiet-mode"
# Find Cygwin's setup utility, or download it from the internet.
# Success: writes the path to Cygwin's setup in $cygsetup
# Failure: aborts.
find_cygsetup () {
  found=false
  for s in "$USERPROFILE/Desktop/setup-x86_64.exe" "$USERPROFILE/Downloads/setup-x86_64.exe" "./setup-x86_64.exe"; do
    if [ -x "$s" ]; then
      echo "Found $cygsetup"
      found=true
      cygsetup="$s"
    fi
  done
  if ! $found; then
    magenta "Cygwin setup not found, downloading it"
    if ! command -v wget >/dev/null 2>&1; then
      red "ERROR: please either place cygwin's setup-x86_64.exe in your Downloads or Desktop folder, or install wget via cygwin's setup"
    fi
    wget "https://cygwin.com/setup-x86_64.exe"
    chmod a+x setup-x86_64.exe
    cygsetup=./setup-x86_64.exe
  fi
}

install_all_opam_packages () {
  packages=$(cat opam-packages | cut -d ' ' -f 2 | tr '\n' ' ')
  opam update
  if is_windows; then
    opam install depext-cygwinports
  fi
  opam depext $packages
  opam install $packages
}

try_git_clone () {
  if ! git clone --recursive $1 $3; then
    magenta "Proceed with https? [Yn]"
    prompt_yes true "exit 1"
    git clone --recursive $2 $3
  fi
}

parse_z3_version () {
  if ! which z3 >/dev/null 2>&1; then
    echo "no z3 in path!"
  else
    local z3_version=$(z3 --version)
    if echo $z3_version | grep hashcode >/dev/null 2>&1; then
      z3 --version | $SED 's/.*build hashcode \(.*\)/\1/' | tr -d '\r'
    else
      z3 --version | $SED 's/Z3 version \([0-9\.]\+\).*/\1/'
    fi
  fi
}

# ------------------------------------------------------------------------------
# The functions that implement the main actions
# ------------------------------------------------------------------------------

do_update_z3 () {
  # Update our clone of FStarLang/binaries and check that we have the blessed z3
  # version
  if ! [[ -d fstarlang_binaries ]]; then
    echo "... cloning FStarLang/binaries"
    try_git_clone "git@github.com:FStarLang/binaries.git" "https://github.com/FStarLang/binaries.git" fstarlang_binaries
  fi
  (cd fstarlang_binaries && git checkout master && git fetch && git reset --hard origin/master)

  local current_z3=$(parse_z3_version)
  echo "... version of z3 found in PATH: $current_z3"

  local hash_of_filename='s/.*\.\([a-z0-9]\+\)-x64.*/\1/'
  if is_windows; then
    local new_z3_file=fstarlang_binaries/z3-tested/*-x64-win.zip
  elif is_osx; then
    local new_z3_file=fstarlang_binaries/z3-tested/*-x64-osx-*.zip
  elif [[ $(lsb_release -i | awk '{ print $3; }') == "Ubuntu" ]]; then
    local new_z3_file=fstarlang_binaries/z3-tested/*-x64-ubuntu-*.zip
  elif [[ $(lsb_release -i | awk '{ print $3; }') == "Debian" ]]; then
    local new_z3_file=fstarlang_binaries/z3-tested/*-x64-debian-*.zip
  else
    red "WARNING: could not figure out your system via lsb_release; defaulting to Debian"
    local new_z3_file=fstarlang_binaries/z3-tested/*-x64-debian-*.zip
  fi
  local new_z3=$(ls $new_z3_file | $SED "$hash_of_filename")
  echo "... version of z3 found in z3-tested is: $new_z3"

  new_z3_file=$(ls $new_z3_file)
  if [[ $new_z3 != $current_z3 ]]; then
    magenta "Get the freshest z3 from FStarLang/binaries? [Yn]"
    prompt_yes true "exit 1"
    echo "... unzipping $new_z3_file"
    unzip $new_z3_file
    local new_z3_folder=${new_z3_file%%.zip}
    new_z3_folder=${new_z3_folder##fstarlang_binaries/z3-tested/}
    find $new_z3_folder -iname '*.dll' -or -iname '*.exe' | xargs chmod a+x
    magenta "Automatically customize $EVEREST_ENV_DEST_FILE with the z3 path? [Yn]"
    prompt_yes "write_z3_env_dest_file $new_z3_folder" true
    ln -sf $new_z3_folder z3
  fi
}

# Windows-only: print out the directory of the Python associated to SCons
windows_scons_python_dir () {
    PYDIR=$(regtool -q get "/HKLM/Software/Python/PythonCore/$SCONS_PYTHON_MAJOR_MINOR/InstallPath/" || true)
    if ! [[ -d $PYDIR ]] ; then
      PYDIR=$(regtool -q get "/HKCU/Software/Python/PythonCore/$SCONS_PYTHON_MAJOR_MINOR/InstallPath/" || true)
    fi
    if ! [[ -d $PYDIR ]] ; then
      red "ERROR: Python $SCONS_PYTHON_MAJOR_MINOR was not installed properly"
      exit 1
    fi
    echo "$PYDIR"
}

# check_windows_scons: (Windows only) checks if Python 3.x and a
# corresponding Scons and pywin32 are installed; and if not, propose
# to install scons and pywin32 along with its required Python
check_windows_scons ()
{
  if command -v scons.bat > /dev/null 2>&1 ; then
    echo "... scons.bat found in PATH"
    # Check whether it corresponds to the right expected version of Python
    scons.bat --file=scons-python-version-test.py
    echo "... scons is well configured for Python $SCONS_PYTHON_MAJOR_MINOR"
  else
    magenta "Warning: scons.bat not found in PATH"
    if ! PYDIR=$(windows_scons_python_dir) ; then
      red "ERROR: No Python $SCONS_PYTHON_MAJOR_MINOR found"
      magenta "Do you want to install Windows Python $SCONS_PYTHON_VER , and scons for that version of Python?"
      prompt_yes true "exit 1"
      local python_file_name="python-$SCONS_PYTHON_VER-amd64.exe"
      wget "https://www.python.org/ftp/python/$SCONS_PYTHON_VER/$python_file_name"
      chmod +x "$python_file_name"
      # From: https://docs.python.org/3/using/windows.html
      "./$python_file_name" /passive
      PYDIR=$(windows_scons_python_dir)
    else
      echo "... Python $SCONS_PYTHON_MAJOR_MINOR found"
    fi
    if "$PYDIR/python.exe" "$PYDIR/Scripts/scons.py" -f scons-python-version-test.py ; then
      echo '... SCons for Python $SCONS_PYTHON_MAJOR_MINOR was detected'
    else
      red "No SCons detected for Python $SCONS_PYTHON_MAJOR_MINOR"
      magenta "Do you want to install SCons $SCONS_VER for Python $SCONS_PYTHON_MAJOR_MINOR ?"
      prompt_yes true "exit 1"
      wget $SCONS_INSTALL_POINT
      tar xf "$SCONS_INSTALL_FILE"
      pushd "$SCONS_INSTALL_DIR"
      "$PYDIR/python.exe" setup.py install # --prefix=$scons_target_wdir
      popd
      # Test whether SCons was installed properly
      "$PYDIR/python.exe" "$PYDIR/Scripts/scons.py" -f scons-python-version-test.py
    fi
    magenta 'The default scons.bat is installed in a directory that cannot be added to PATH,'
    magenta 'because that directory contains a python.exe, which would shadow the already'
    magenta 'existing python command that shall point to a Python 2.x.'
    magenta 'Do you want to create a new scons.bat and have PATH point to it?'
    if prompt_yes true false
    then
      pydir_dos=$(cygpath -d "$PYDIR")
      mkdir -p scons
      echo "$pydir_dos/python.exe $pydir_dos/Scripts/scons.py "'%*' > scons/scons.bat
      chmod +x scons/scons.bat
      windows_append_path "$PWD/scons"
    fi
  fi
  # Also test for pywin32
  echo "checking for pywin32"
  if ! PYDIR=$(windows_scons_python_dir) ; then
    red "ERROR: Python $SCONS_PYTHON_MAJOR_MINOR was not installed properly"
    exit 1
  fi
  if "$PYDIR/Scripts/pip.exe" show pywin32 ; then
    echo "... pywin32 found"
  else
    red "pywin32 does not seem to be installed for Python $SCONS_PYTHON_MAJOR_MINOR"
    magenta "Do you want to install it?"
    prompt_yes true "exit 1"
    "$PYDIR/Scripts/pip.exe" install pywin32
  fi
}

do_check ()
{
  blue "Checking environment"

  # Basic utilities
  success_or "which" "please execute this script in a Unix environment"
  if is_osx; then
    success_or "greadlink" "please run \"brew install coreutils\""
    success_or "gsed" "please run \"brew install gnu-sed\""
    success_or "gfind" "please run \"brew install findutils\""
  fi

  # Slightly suboptimal, since we may end up running Cygwin's setup twice.
  if ! command -v git >/dev/null 2>&1; then
    if is_windows; then
      magenta "Git not found. Install Cygwin's git? [Yn]"
      find_cygsetup
      prompt_yes "$cygsetup $cygsetup_args --packages=git"
    else
      red "ERROR: git not found; install it via your favorite package manager"
      exit 1
    fi
  fi

  # Windows pre-requisites
  if is_windows; then
    # A list of known causes for failure
    if where.exe bash.exe | grep -v cygwin >/dev/null 2>&1; then
      red "ERROR: bash.exe has been found in a non-standard location!"
      echo "Please remove Bash for Windows and others (GNU for Windows, MSYS2, etc.)"
      red "Are you sure you want to continue? [Yn]"
      prompt_yes true "exit 1"
    else
      echo "... no suspicious bash"
    fi

    if [[ $(uname -m) != "x86_64" ]]; then
      red "ERROR: not a 64-bit Cygwin"
      echo "We've experienced tons of issues with 32-bit Cygwin. Time to upgrade."
      exit 1
    fi
    echo "... 64-bit cygwin"

    if cygwin_has "ocaml" || cygwin_has "flexdll"; then
      red "ERROR: please remove the cygwin ocaml and/or flexdll packages"
      exit 1
    fi
    echo "... no suspicious cygwin packages"

    if ! (flexlink.exe -help 2>&1 || true) | grep "fdopen" >/dev/null; then
        red "Warning: you have an unknown version of flexlink"
        red "Please use the version from https://fdopen.github.io/opam-repository-mingw/"
    else
        echo "... flexlink is good"
    fi

    # The list of required cygwin packages
    for p in $(cat cygwin-packages); do
      if ! cygwin_has $p; then
        find_cygsetup
        echo "Cygwin package $p is missing"
        if_yes "$cygsetup $cygsetup_args --packages=$(cat cygwin-packages | tr '\n' ,)"
      fi
    done
    echo "... all $(cat cygwin-packages | wc -l) cygwin packages seem to be installed"

    if ! command -v libsqlite3-0.dll >/dev/null 2>&1; then
      red "Warning: x86_64-mingw32 DLLs not in PATH"
      magenta "Automatically customize $EVEREST_ENV_DEST_FILE with the x86_64-mingw32 path + native windows symlinks?"
      prompt_yes write_cygwin_env_dest_file true
    else
      echo "... proper mingw directory seems to be in PATH"
    fi
  fi # if is_windows

  # Note: ssh returns the exit code of the remote command (1 in this case),
  # hence the || true -- the success of this step is determined by the presence
  # of "authenticated".
  if ! (ssh -oStrictHostKeyChecking=no git@github.com 2>&1 || true) | grep authenticated >/dev/null; then
    magenta "Warning: git client not configured with the proper ssh credentials"
    echo "Hint: check which git you're running, and make sure you have the same SSH key in ~/.ssh and github.com"
  else
    echo "... github.com access ok"
  fi

  # OCaml detection
  if ! command -v >/dev/null 2>&1 ocaml; then
    # Offer to install and sed-setup a crappy snapshot
    if is_windows; then
      magenta "No OCaml detected!"
      cat <<MSG

Proceed with the download?
MSG
      prompt_yes true "exit 1"
      if [ -e ~/.opam ]; then
        red "Warning: stale ~/.opam; continue? [Yn]"
        prompt_yes true "exit 1"
      fi
      if [ -e /cygdrive/c/ocamlmgw64 ]; then
        red "Warning: stale /cygdrive/c/ocamlmgw64; continue? [Yn]"
        prompt_yes true "exit 1"
      fi
      # Download and Install OPAM
      wget $OPAM_URL
      tar -xf 'opam64.tar.xz'
      rm -f 'opam64.tar.xz'
      bash opam64/install.sh
      echo "Interactive is: $INTERACTIVE ; auto-setup is: $OPAM_AUTO_SETUP ; dot-profile is: $EVEREST_ENV_DEST_FILE ;"
      opam init mingw 'https://github.com/fdopen/opam-repository-mingw.git' --comp $OPAM_VERSION --switch $OPAM_VERSION --dot-profile "$EVEREST_ENV_DEST_FILE" $OPAM_AUTO_SETUP
      if { ! $INTERACTIVE ; } && ! grep 'opam-init' "$EVEREST_ENV_DEST_FILE"  >/dev/null ; then
        # --auto-setup might not have worked, so manually do it here.
        # Do not expand variables in the textual output.
        echo '. "$HOME/.opam/opam-init/init.sh" > /dev/null 2>/dev/null' >> "$EVEREST_ENV_DEST_FILE"
      fi
      eval $(opam config env)
    else
      red "ERROR: no ocaml found in PATH"
      if is_osx; then
        echo "Hint: brew install ocaml opam"
      else
        echo "Please use your distribution's package management system to install ocaml and opam"
        echo "Note: on older Ubuntus, see https://launchpad.net/~avsm/+archive/ubuntu/ppa"
      fi
      exit 1
    fi

  else
    # OCaml; if this exits, set -e means this is a hard error
    ocaml -noinit -noprompt -stdin <<OCAML
      if Sys.ocaml_version < "4.04.0" then begin
        print_endline "ERROR: Everest needs OCaml >= 4.04.0";
        print_endline ("You have OCaml " ^ Sys.ocaml_version);
        exit 1
      end
OCAML
    echo "... ocaml minimum version requirements met"
  fi

  # OCamlfind & extra packages. Required OPAM packages are stored in
  # [opam-packages], where each line is of the form:
  #   <ocamlfind-package-name> <SPACE> <opam-package-name>
  success_or "opam"
  if [ ! -d ~/.opam ]; then
    if is_windows; then
      echo "This is a Windows environment; not running opam init."
      echo "Please follow instructions for the installer you picked."
      echo "Hint: https://github.com/protz/ocaml-installer/wiki or https://fdopen.github.io/opam-repository-mingw/"
    else
      if_yes "opam init"
    fi
    eval $(opam config env)
  fi

  if ! command -v ocamlfind >/dev/null 2>&1; then
    magenta "ocamlfind not found!"
    if_yes "opam install ocamlfind"
  fi

  missing=false
  while read line; do
    ocamlfind_package=$(echo $line | cut -d " " -f 1)
    opam_package=$(echo $line | cut -d " " -f 2)
    if ! ocamlfind query $ocamlfind_package >/dev/null 2>&1; then
      red "ERROR: ocamlfind package $ocamlfind_package is not installed"
      missing=true
      break
    fi
  done < opam-packages
  if $missing; then
    if_yes "install_all_opam_packages"
  fi
  echo "... all $(cat opam-packages | wc -l) ocamlfind packages found"

  # Check for caveats using my OCaml installer
  if ! (cd test && ocamlbuild test.native -use-ocamlfind >/dev/null 2>&1); then
    red "Cannot compile the test OCaml program"
    red "Maybe you've been using the OCaml installer for windows"
    echo Suggestion: check \
      https://github.com/protz/ocaml-installer/wiki#package-specific-hints and \
      follow instructions for ppx deriving and friends
    exit 1
  fi
  echo "... sample ocamlbuild project compiles successfully"

  if is_windows && [ -d "/cygdrive/c/OCaml/lib/camlp4" ] && [[ $CAMLP4LIB == "" ]]; then
    red "Warning: seems like you're using the OCaml installer for windows"
    echo There is a bug in the installer -- please see \
      https://github.com/protz/ocaml-installer/wiki#configure-your-initial-opam-setup \
      and add \"export CAMLP4LIB=C:/OCaml/lib/camlp4\" in your "$EVEREST_ENV_DEST_FILE"
  fi

  # Check for Node.js
  if ! which node >/dev/null 2>&1 ; then
    red "ERROR: Node.js doesn\'t seem to be installed"
    if is_windows ; then
      magenta "Download it from the internet? [Yn]"
      prompt_yes true "exit 1"
      # There is no clean way to determine the latest version of
      # Node.js available. However, the URL below points to a HTML
      # page containing a list of files, and there, there is exactly
      # one link to a .msi file corresponding to 64-bit platforms. So
      # we just need to extract its name from the page.
      NODEJS_MSI=$(wget --output-document=- --no-verbose --quiet https://nodejs.org/dist/latest/ | grep -o '"node-[^-]*-x64\.msi"' | sed 's!"!!g')
      # Check that there are exactly one .msi file there
      test $(echo "$NODEJS_MSI" | grep -o '\.msi' | wc -l) -eq 1
      # Finally, launch Windows installer in unattended mode
      msiexec /i "https://nodejs.org/dist/latest/$NODEJS_MSI" /quiet /passive
      # Test whether Node.js installed properly
      # Impossible: Windows PATH has changed, we cannot refresh it
      # which node > /dev/null 2>&1
      red "CRITICAL: Windows PATH has changed, please restart a new Cygwin window"
    else
      echo 'Please go to https://nodejs.org/ to know how to'
      echo 'install it on your platform'
      exit 1
    fi
  fi
  echo "... Node.js found in PATH"

  # F# and MS compilers (note: nothing for OSX/Linux right now)
  if is_windows; then
    # note: nothing left, we will use vcvarsall.bat/vsdevcmd.bat instead
    true
  else
    success_or "fsharpc" "brew install mono or use your favorite package manager"
  fi
  echo "... fsc found in PATH"

  do_update_z3

  # Check whether python points to a python2
  if which python > /dev/null 2>&1 ; then
    # nasty: python outputs its version on STDERR
    if python --version 2>&1 | grep '^Python 2\.' 2>/dev/null ; then
      echo "... python found in PATH, points to some Python 2.x"
    else
      red "ERROR: python points to something that is not a Python 2.x"
      red "Please fix this according to your platform"
      exit 1
    fi
  else
    magenta "WARNING: python not found in PATH"
  fi

  # Check for Python 2
  if ! which python2 >/dev/null 2>&1 ; then
    red "ERROR: python2 not found in PATH"
    magenta "Do you want to install a Cygwin python2?"
    find_cygsetup
    cygcmd="$cygsetup $cygsetup_args --packages=python2"
    echo "$cygcmd"
    prompt_yes "$cygcmd"
  else
    echo "... python2 found in PATH"
  fi

  # We need Scons for Vale which needs Python 3
  if is_windows; then
    check_windows_scons
  else # *nix
    if ! command -v scons >/dev/null 2>&1; then
      red "ERROR: scons not installed -- please install"
      exit 1
    else
      echo "... scons found in PATH"
      if ! which python$SCONS_PYTHON_MAJOR_MINOR > /dev/null 2>&1 ; then
        red "ERROR: python$SCONS_PYTHON_MAJOR_MINOR not found in PATH"
        red "Please install Python $SCONS_PYTHON_MAJOR_MINOR or higher"
        exit 1
      fi
      echo "... python$SCONS_PYTHON_MAJOR_MINOR found in PATH"
      # Check whether it corresponds to a Python 3.6 or above
      python$SCONS_PYTHON_MAJOR_MINOR $(which scons) --file=scons-python-version-test.py
      echo "... python$SCONS_PYTHON_MAJOR_MINOR is recent enough"
    fi
  fi

  if [[ -z "$EVEREST_SCONS_CACHE_DIR" ]]; then
    echo "Warning: Scons cache directory not set. Set it?"
    prompt_yes write_everest_env_dest_file true
  fi

  if is_windows; then
    if [[ $(echo $FSTAR_HOME | cut -c 1 | tr -d '\r\n' ) == "/" ]]; then
      magenta "You are on windows but your FSTAR_HOME is a Cygwin-style path."
      magenta "Don't do that, follow the suggestion below, and check all your other *_HOME variables."
      unset FSTAR_HOME
    fi
  fi

  echo
  magenta "Remember to run source \"$EVEREST_ENV_DEST_FILE\" if it was modified!"
  local xpwd=""
  if is_windows; then
      xpwd="$(cygpath -m $(pwd))"
  else
      xpwd="$(pwd)"
  fi

  magenta "Note: you *may* want to add ${xpwd}/FStar/bin and ${xpwd}/kremlin to your PATH"
  [ -n "${FSTAR_HOME}" ] || \
    magenta "Note: you *may* want to export FSTAR_HOME=${xpwd}/FStar"
  [ -n "${KREMLIN_HOME}" ] || \
    magenta "Note: you *may* want to export KREMLIN_HOME=${xpwd}/kremlin"
  [ -n "${HACL_HOME}" ] || \
    magenta "Note: you *may* want to export HACL_HOME=${xpwd}/hacl-star"
}

get_vale ()
{
  mkdir vale
  vale_version=$(<hacl-star/vale/.vale_version)
  wget "https://github.com/project-everest/vale/releases/download/v${vale_version}/vale-release-${vale_version}.zip" -O vale/vale-release.zip
  rm -rf "vale/vale-release-${vale_version}"
  unzip -o vale/vale-release.zip -d vale
  rm -rf "vale/bin"
  mv "vale/vale-release-${vale_version}/bin" vale/
}

self_update () {
  old_revision=$(git rev-parse HEAD)
  git pull --rebase
  if [[ $(git rev-parse HEAD) != $old_revision ]]; then
    blue "Self-updating to new everest revision $(git rev-parse HEAD | cut -c 1-8)"
    # Now, we transfer execution to the new version of $0
    cd "$initial_pwd"
    exec "${@/pull/}"
  else
    echo "No new everest revision available"
  fi
}

do_pull () {
  source hashes.sh
  source repositories.sh
  echo Reset working copies
  do_reset
}

do_reset ()
{
  warned=false
  for r in $ALL_PROJECTS; do
    echo
    blue "Pulling $r"
    # Some sanity checks, and clone the repositories that aren't there already
    if [ ! -d $r ]; then
      if [ -e $r ]; then
        red "$r exists but is not a directory, aborting"
        exit 1
      fi
      if ! $warned; then
        echo Note: you\'re welcome to create symbolic links if you already have \
          cloned the repository elsewhere
        warned=true
      fi
      try_git_clone ${repositories[$r]} ${https[$r]} $r
    fi

    # Note: the snapshot command guarantees that the commit was pushed to a
    # branch of the form origin/foo. So, we checkout foo, because there's a good
    # chance it tracks origin/foo which contains the commit we want. If it's not
    # the case it's a crazy setup and the user is on their own.
    cd $r
    git fetch
    hash=${hashes[$r]}
    branch=${branches[$r]}
    if [[ $(git symbolic-ref HEAD) != $branch ]]; then
      git checkout -f $branch
    fi
    # Note: this is not super robust in the face of weird cases like someone
    # having a local branch named origin/master, in which case [upstream] will
    # contain "remotes/origin/master"... alternate solution:
    # local found=false
    # for b in $(git branch -r --contains $hash | awk '{ print $0; }'); do
    #   if [[ $upstream == $(git rev-parse --abbrev-ref --symbolic-full-name $b@{u} ]]; then
    #     found=true
    #   fi
    #  done
    # if ! $found; then
    #   etc.
    # fi
    # Note: the --format option of git branch would be better than awk but a lot of
    # people are stuck on git 2.8, including cygwin and Azure VMs.
    upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u})
    if ! git branch -r --contains $hash | egrep "^ +$upstream$" >/dev/null 2>&1; then
      red "ERROR: in repository $r, the hash $hash claims to belong to branch \
        $branch, but $branch pulls from $upstream which does not contain $hash"
      exit 1
    fi
    git reset --hard $hash
    git submodule update --init
    cd ..
  done
  get_vale
}

do_merge ()
{
  self_update
  blue "Merging working copies"
  for r in $ALL_PROJECTS; do
    echo
    blue "Pulling and rebasing $r"
    cd $r
    git pull --rebase
    cd ..
  done
}

do_forall ()
{
  #blue "Executing on toplevel"
  #"$@"
  for r in ${!repositories[@]}; do
    echo
    blue "Executing in $r"
    cd $r
    "$@"
    cd ..
  done
}

# OS-independent scons. chdir to $1, then passes $2 to scons.
# The return status is that of the last command.
run_scons () {
  short_dir="$1"
  shift
  cmd="$1"
  
  if is_windows ; then
    DIR=$(cygpath -w "$(pwd)"/"$short_dir")
  else
    DIR="$short_dir"
  fi
  
  if is_windows; then
    # Instead of invoking cmd.exe /c, which would force us to
    # rely on its flaky semantics for double quotes,
    # we go through a batch file.
    THIS_PID=$$
    # Find an unambiguous file name for our .bat file
    SCONS_EXECS=0
    while
      SCONS_INVOKE_FILE="everest$THIS_PID""scons$SCONS_EXECS"".bat" &&
      [[ -e "$SCONS_INVOKE_FILE" ]]
    do
      SCONS_EXECS=$(($SCONS_EXECS + 1))
    done
    # Then create, run and remove the .bat file
    cat > "$SCONS_INVOKE_FILE" <<EOF
call $VS_ENV_CMD
cd "$DIR"
EOF
    if command -v scons.bat > /dev/null 2>&1 ; then
      echo "call scons.bat $cmd $parallel_opt" >> "$SCONS_INVOKE_FILE"
    else
      PYDIR=$(cygpath -d $(windows_scons_python_dir))
      echo "$PYDIR/python.exe $PYDIR/Scripts/scons.py $cmd $parallel_opt" >> "$SCONS_INVOKE_FILE"
    fi
    chmod +x "$SCONS_INVOKE_FILE"
    "./$SCONS_INVOKE_FILE"
    SCONS_RETCODE=$?
    rm -f "$SCONS_INVOKE_FILE"
    return $SCONS_RETCODE
  else
    python$SCONS_PYTHON_MAJOR_MINOR $(which scons) -C "$DIR" $cmd $parallel_opt
  fi
}

run_hacl_vale_scons () {
  run_scons hacl-star/vale "--FSTAR-MY-VERSION $1 --FSTAR-EXTRACT"
}

clean_hacl () {
  for f in \
    hacl-star/{code,secure_api,providers} \
  ; do
    if test -d "$f" ; then
      make -C "$f" clean
    fi
  done
  run_hacl_vale_scons "--clean"
}

setup_env () {
  if is_windows; then
    export FSTAR_HOME=$(cygpath -m $(pwd)/FStar)
    export VALE_HOME=$(cygpath -m $(pwd)/vale)
    export KREMLIN_HOME=$(cygpath -m $(pwd)/kremlin)
    export HACL_HOME=$(cygpath -m $(pwd)/hacl-star)
    export MLCRYPTO_HOME=$(cygpath -m $(pwd)/MLCrypto)
  else
    export FSTAR_HOME=$(pwd)/FStar
    export VALE_HOME=$(pwd)/vale
    export KREMLIN_HOME=$(pwd)/kremlin
    export HACL_HOME=$(pwd)/hacl-star
    export MLCRYPTO_HOME=$(pwd)/MLCrypto
  fi
  export OPENSSL_HOME=$MLCRYPTO_HOME/openssl
  magenta "exported FSTAR_HOME=$FSTAR_HOME"
  magenta "exported OPENSSL_HOME=$OPENSSL_HOME"
  magenta "exported KREMLIN_HOME=$KREMLIN_HOME"
  magenta "exported VALE_HOME=$VALE_HOME"
  magenta "exported HACL_HOME=$HACL_HOME"
  magenta "exported MLCRYPTO_HOME=$MLCRYPTO_HOME"
  export PATH=$(pwd)/FStar/bin:$(pwd)/kremlin:$PATH

  if is_windows; then
    export PATH=$(cygpath -u $OPENSSL_HOME):$PATH
  elif [[ $(uname) == "Darwin" ]]; then
    export DYLD_LIBRARY_PATH=$OPENSSL_HOME:$DYLD_LIBRARY_PATH
    magenta "exported DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH"
  else
    export LD_LIBRARY_PATH=$OPENSSL_HOME:$LD_LIBRARY_PATH
    magenta "exported LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
  fi
  magenta "exported PATH=$PATH"
}

separator () {
  echo "================================================================================"
}

set_windows () {
  export EVEREST_WINDOWS=1
}

set_opt () {
  # Picked up by pretty much all the Makefiles
  export CFLAGS="-funroll-loops -fomit-frame-pointer -O3"
}

set_openssl () {
  # Picked up by mitls-fstar/src/tls/Makefile.Kremlin
  export MITLS_USE_OPENSSL=1
}

build_fstar () {
  make -C FStar/src/ocaml-output $parallel_opt && \
  make -C FStar/ulib $parallel_opt && \
  make -C FStar/ulib/ml $parallel_opt
}

build_kremlin () {
  # TODO: run the kremlin testsuite too
  make -C kremlin $parallel_opt &&
  make -C kremlin/kremlib $parallel_opt
}

build_hacl () {
  make -C hacl-star $parallel_opt && \
  make -C hacl-star test $parallel_opt
}

build_mitls () {
  CFLAGS="$MITLS_CFLAGS" \
  make -C mitls-fstar/libs/ffi $parallel_opt && \
  make -C mitls-fstar/src/pki $parallel_opt && \
  VERIFY_LOWPARSE=1 make -C mitls-fstar/src/tls $parallel_opt && \
  make -C mitls-fstar/apps/cmitls $parallel_opt && \
  make -C mitls-fstar/apps/quicMinusNet $parallel_opt
}

do_make ()
{
  setup_env
  failed=""
  mkdir -p log

  declare -A build_commands
  build_commands[FStar]="build_fstar"
  build_commands[kremlin]="build_kremlin"
  build_commands[MLCrypto]="make -C MLCrypto $parallel_opt"
  build_commands[hacl-star]="build_hacl"
  build_commands[mitls-fstar]="build_mitls"
  build_commands[quackyducky]="make -C quackyducky $parallel_opt"

  # Order matters.
  for p in FStar kremlin MLCrypto hacl-star quackyducky mitls-fstar; do
    # For individual components, we set ALL_PROJECTS=foo
    if [[ ${ALL_PROJECTS/$p/} == $ALL_PROJECTS ]]; then
      continue
    fi
    separator
    blue "Rebuilding $p"
    blue "Running: ${build_commands[$p]}"
    if ! ${build_commands[$p]} ; then
      separator
      red "FAILURE: build failed for $p"
      return 2
    fi
    separator
    echo -e "\n\n"
  done

  green "SUCCESS"
}

do_test () {
  setup_env

  separator
  blue "Running tests (commands shown below)"
  set -x
  make -C kremlin/test $parallel_opt everything
  IMPL_CHOICE=runtime_switch make -C hacl-star/secure_api -f Makefile.extract test $keep_going_opt
  hacl-star/secure_api/out/runtime_switch/krml-test.exe
  make -C quackyducky $parallel_opt test
  # These tests make assumption on their current working directory
  (cd mitls-fstar/src/tls && make $parallel_opt $keep_going_opt test)
  (cd mitls-fstar/apps/cmitls && make $keep_going_opt test)
  (cd mitls-fstar/apps/quicMinusNet && make $keep_going_opt test)
  set +x
  separator
}

do_verify () {
  setup_env

  declare -A verify_commands
  verify_commands[FStar]="make -C FStar/src ulong $parallel_opt $keep_going_opt"
  verify_commands[kremlin]="echo nothing to verify for kremlin"
  verify_commands[hacl-star]="make -C hacl-star $parallel_opt -k verify"
  verify_commands[mitls-fstar]="make -C mitls-fstar/src/tls verify $parallel_opt -k"
  verify_commands[MLCrypto]="echo nothing to verify for MLCrypto"
  verify_commands[quackyducky]="echo nothing to verify for quackyducky"

  for p in $ALL_PROJECTS; do
    separator
    blue "Running verification for: $p"
    ${verify_commands[$p]}
    separator
  done
}

do_clean_c ()
{
  setup_env
  for d in kremlin/kremlib hacl-star/{providers,secure_api,code} \
    mitls-fstar/src/tls
  do
    if test -d "$d" ; then
      make -C "$d" clean-c
    fi
  done
}

do_clean ()
{
  setup_env
  for d in FStar/ulib/ml FStar/src{,/ocaml-output} \
    MLCrypto/{,openssl} \
    quackyducky/out quackyducky \
    mitls-fstar/src/tls \
    kremlin \
    ; do
    if test -d "$d" ; then
      make -C "$d" clean
    fi
  done
  clean_hacl
}

do_snapshot ()
{
  blue "Recording a new snapshot"
  echo "declare -A hashes" > new-hashes.sh
  echo "declare -A branches" >> new-hashes.sh
  for r in ${!repositories[@]}; do
    cd $r
    head=$(git rev-parse HEAD)
    branch=$(git symbolic-ref HEAD)
    branch=${branch##refs/heads/}
    upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u})
    if [[ $upstream != "origin/$branch" ]]; then
      red "ERROR: in repository $r, HEAD ($head) is on $branch which pushes to \
        $upstream, not origin/$branch!"
    fi
    if ! git branch -r --contains $head | egrep "origin/$branch$" >/dev/null 2>&1; then
      red "ERROR: in repository $r, HEAD ($head) is on $branch which has not
        been pushed to $upstream"
    fi
    cd ..
    echo "recording $r at revision $(echo $head | cut -c 1-8) ($branch)"
    echo "hashes[$r]=$head" >> new-hashes.sh
    echo "branches[$r]=$branch" >> new-hashes.sh
  done
  mv new-hashes.sh hashes.sh
  cat <<MSG

New hashes have been recorded in hashes.sh. You can see the changes with git
diff.

If you intend to make this set of working revisions widely available, then you
must run commit and push.
MSG
}

do_drop ()
{
  setup_env

  blue "Dropping sources for Windows libraries"
  ./make-source-drop mitls-fstar/src/windows
}

do_qbuild ()
{
  setup_env

  blue "Building Windows libraries"
  # Instead of invoking cmd.exe /c, which would force us to
  # rely on its flaky semantics for double quotes,
  # we go through a batch file.
  THIS_PID=$$
  # Find an unambiguous file name for our .bat file
  NMAKE_EXECS=0
  while
    NMAKE_INVOKE_FILE="everest$THIS_PID""nmake$NMAKE_EXECS"".bat" &&
    [[ -e "$NMAKE_INVOKE_FILE" ]]
  do
    NMAKE_EXECS=$(($NMAKE_EXECS + 1))
  done
  # Then create, run and remove the .bat file
  DIR=$(cygpath -w "$(pwd)/mitls-fstar/src/windows")
  cat > "$NMAKE_INVOKE_FILE" <<EOF
call $VS_ENV_CMD
set MAKEFLAGS=
set KRML_HOME=..\..\..\kremlin
cd "$DIR\kremlib" &&^
call nmake -f makefile.vs &&^
cd "$DIR\evercrypt" &&^
call nmake -f makefile.vs &&^
cd "$DIR\quiccrypto" &&^
call nmake -f makefile.vs &&^
cd "$DIR\mitls" &&^
call nmake -f makefile.vs
EOF
  chmod +x "$NMAKE_INVOKE_FILE"
  "./$NMAKE_INVOKE_FILE"
  NMAKE_RETCODE=$?
  rm -f "$NMAKE_INVOKE_FILE"
  return $NMAKE_RETCODE
}

# ------------------------------------------------------------------------------
# Usage and parsing arguments
# ------------------------------------------------------------------------------

print_usage ()
{
  cat <<HELP
OVERVIEW: $0, a high-level management script for Project Everest

USAGE: $0 [OPTIONS] [PROJECT] COMMANDS

OPTION:
  --yes     Non-interactive mode (answer y to all questions, verbose)

  -j n      Set max number of parallel jobs to n (default 1)
            This option is in two parts
            (-jn without space is NOT valid)

  -windows  Build for Windows (Tune for MSVC compiler: optimize tail recursion, etc.)

  -k        Pass the -k (--keep-going) option to "make"

  -opt      Enable classic optimization flags and disable debugging. Note: this
            does not invalidate previous object files (e.g. in HACL*); consider
            cleaning.

  -openssl  Use OpenSSL for AEAD in miTLS

PROJECT:
  restrict the subsequent commands to operate on one of the following:
    FStar kremlin mitls-fstar hacl-star MLCrypto quackyducky

COMMAND:
  check     ensure that all the required programs are found in path, install
            them if needed; offer to customize ~/.bash_profile with proper env
            variables
            (destination file ~/.bash_profile can be overridden with the
            EVEREST_ENV_DEST_FILE environment variable)

  opam      install the needed OPAM packages (implied by check)

  z3        install the right version of z3 (implied by check)

  pull      self-update the everest repository (i.e. the script and
            hashes.sh) then run reset

  merge     pull all projects, merging and rebasing local changes; does NOT
            reset to known to be good version, but preserves your changes

  forall    execute command in all git repository directories

  reset     pull all projects and move them to the revisions specified by
            hashes.sh

  snapshot  make the current state a new known set of working revisions; this
            writes into hashes.sh

  make      rebuild all projects

  test      launch the test artifacts

  verify    run verification for all projects

  drop      drop extraced C and assembly files from miTLS and Hacl*

  qbuild    build Windows libraries using Visual Studio

  clean-c   only clean generated C files, useful when switching to -windows

  clean     clean all projects

  help      print the current message
HELP
}

if [[ $1 == "" ]]; then
  print_usage
  exit 0
fi

while true; do
  case "$1" in
    --yes)
      make_non_interactive
      ;;

    -j)
      # The -j option is in two parts: -j n, where n is the parallel factor
      # (max number of parallel jobs)
      shift
      parallel_opt="-j $1"
      ;;

    -k)
      keep_going_opt="-k"
      ;;

    -windows)
      set_windows
      ;;

    -openssl)
      set_openssl
      ;;

    -opt)
      set_opt
      ;;

    check)
      do_check
      ;;

    pull)
      self_update
      do_pull
      ;;

    pull_projects)
      do_pull
      ;;

    merge)
      do_merge
      ;;

    forall)
      shift
      do_forall "$@"
      break
      ;;

    FStar|mitls-fstar|kremlin|hacl-star|MLCrypto|quackyducky)
      ALL_PROJECTS=$1
      ;;

    reset)
      do_reset
      ;;

    make)
      do_make
      ;;

    opam)
      install_all_opam_packages
      ;;

    z3)
      do_update_z3
      ;;

    clean)
      do_clean
      ;;

    clean-c)
      do_clean_c
      ;;

    verify)
#      Disable verification for now
#      do_verify
      red "The 'verify' command is obsoleted by 'make'. Just run './everest make' instead."
      ;;

    test)
      do_test
      ;;

    snapshot)
      do_snapshot
      ;;

    drop)
      do_drop
      ;;

    qbuild)
      do_qbuild
      ;;

    "")
      break
      ;;

    *)
      print_usage
      exit 1
      ;;
  esac
  shift
done
